---
output: html_document
---
  
   
<img align = "right" src="https://www2.gmu.edu/sites/all/modules/features/feature_base_theme/templates/resources/images/mason-logo.png" height="150px" width = "150px"/>
    
  <img align = "right" src="https://upload.wikimedia.org/wikipedia/en/6/6a/Smithsonian_Conservation_Biology_Institute_logo.png" height="150px" width = "150px"/>
  
# For Loops and Functions
_Brian S. Evans  
Smithsonian Conservation Biology Institute  
Migratory Bird Center_

### Before you begin:
For this lesson, we will use an example data frame of bird observations. Open R Studio and run the following script to load the data into R:

```{r, eval=FALSE}
# Load the library

require(RCurl)

# Provide the web address of the file:

fileURL <- getURL('https://raw.githubusercontent.com/SCBI-MigBirds/MigBirds/master/data/exampleBirdData.csv')

# Read in the data:

birdCounts <- read.csv(text = fileURL)
```

### For loops

While there are many functions out there that replace the necessity of for loops, you will inevitably have to use them at some point in your data analyses. As such, understanding how they work is critical.

For loops require three components:

1. An empty vector, matrix, or list item for the loop to create
2. The **For loop initialization**: The locations for which the loop will run
3. The **For instuctions**: what will occur during each iteration of the loop

Let's create some example data using the first five counts in birdCounts:

```{r, eval=FALSE}
V0 <- birdCounts$count[1:5]
V0
```

The value V0[i] is equal to the value at position i in vector V0. Let's take a look at the value of V0 at position 3:

```{r, eval=FALSE}
V0[3]
```

We'll start with a very simple loop. We would like to add one to each number in vector V0 and store the results in a new vector, V1. This would be written mathematically as:

$$V_{1, i} =  V_{0, i} + 1$$


First, we create an empty vector, V1, to store the results (Note: We specify the length of the vector to provide R with stopping rules -- with big data _for loops_ can become very memory hungry):

```{r, eval=FALSE}
V1 <- numeric(length = length(V0))
```

If we want to calculate V0 + 1 at position 3 for our new vector V1, we would write:

```{r, eval=FALSE}
V1[3] <- V0[3] + 1
```

Let's compare the initial value of V0 with the resultant value of V1 at position 3:

```{r, eval=FALSE}
V0[3]

V1[3]
```

The utility of the _for loop_ is that we can calculate the above for each position ("i") in vector V0. This is done by setting the "**for loop initialization**" statement which defines the locations over which the _for loop_ will be calculated. The _for loop initialization_ for locations one through five is written as (**DO NOT RUN**):

```{r, eval=FALSE}
for(i in 1:5)
```

The above can be translated as "for position i in positions 1 through five".

Because we can determine the length of a vector using the length function (`length(V0)`), we can specify the end point for the  _for loop initialization_ statement as (**DO NOT RUN**):

```{r, eval=FALSE}
for(i in 1:length(V0))
```

The _for loop initialization_ statement is followed by the "**for instructions**" statement that provides instructions for what will happen during each iteration of the loop (with the _for instructions_ surrounded by "{}"). The _for instructions_ associated with our "add one" formula is (**DO NOT RUN**): 

```{r, eval=FALSE}
{V1[i] <- V0[i] + 1}
```

Putting together our _for loop initialization_ and _for instructions_ statements, our completed _for loop_ is written as (**RUN THIS ONE**):

```{r, eval=FALSE}
for(i in 1:length(V0)){
  V1[i] <- V0[i] + 1
}
```

Take a look at the output and compare it with the values of V0:

```{r, eval=FALSE}
V1

V0
```

When writing _for loops_, it is necessary to ensure that the loop is doing what you expect it to do. A simple way to ensure that this is the case is to specify _i_ and run the _for instructions_. For example, to observe the behavior of the _for loop_ at position 3:

```{r, eval=FALSE}

i = 3

V1[i] <- V0[i] + 1

V1[i]

V0[i]

```

----

> **Exercise One:**
>
> One of my favorite for loops was created by Leonardo Bonacci (Fibonacci). He created the first known population model, from which the famous Fibonacci number series was created. He described a population (N) at time t as the sum of the population at the previous time step plus the time step before that:
>
>$$N_t = N_{t-1} + N_{t-2}$$
>
> Use the formula above to generate the first 20 numbers of the  Fibonacci number sequence.
> 
>* _**Hint 1**: Unlike our work above, there is only one vector in this formula (the size of the population at time t). The first two values of the number sequence must be set in advance. They are 0 and 1._
>* _**Hint 2**: Time "t-1" is written in R as "[i-1]"._


## Functions

In the introductory lesson, we worked with several functions (e.g., "c", "mean"). Unfortunately, the process of learning R involves learning the many functions within R and its many user-built packages. While this is inevitable, it is also necessary to learn how to build your own functions to simplify your scripts and deal with problems that may arise for which canned functions just don't do the trick.

Functions allow you to simplify complex tasks, which is especially useful if you need to run a task multiple times. R has many, many functions built in. R packages (or libraries) are collections of functions that help further simplify tasks. As tasks become more complex, however, it is inevitable that you will have to customize your own or existing functions to suit your needs.

### Running a built-in function

Consider a vector, x, that contains 6 numbers: 1, 1, 2, 3, 5, and 8. If you wanted to add up all of the elements in x, you could either add elements individually, as you would on a calculator, or simply use the built-in “sum” function. To run a function, you type the name of the function and then parentheses enclosing the object that you wish to run the function on.

```{r, eval=FALSE}
1+1+2+3+5+8
x <- c(1,1,2,3,5,8)
sum(x)
```

_Note: Recall that c(), above, is the "combine" function, which combines elements into a vector._

### Writing simple functions
Writing your own functions is easy, as long as you follow the correct syntax. The basic structure is:

```{r, eval=FALSE}
theNameOfMyFunction <- function(objectToComputeFunctionFor) {
	What you would like to happen when you run your function
}
```

_Note: The curly brackets above are only necessary if your function is more  than one line. If your function is one line you do not need to include them._
Let’s write a function that adds 1 to every number in our vector x above.

```{r, eval=FALSE}
addOneFun <- function (x) x + 1
```

Which could also be written as:

```{r, eval=FALSE}
addOneFun <- function(x){
	x+1
}
```

You then can run the addOneFun function by typing:

```{r, eval=FALSE}
addOneFun(x)
```

Let's try writing a more meaningful function. Recall from the last lesson that we used logic to subset the BirdCounts data frame as below:

```{r, eval=FALSE}
birdCounts[birdCounts$foraging == 'aerial','counts']
```

Let's embed this line of code within a function to extract the sum of counts for a given foraging guild:

```{r, eval=FALSE}
foragingSumFun <- function(foragingGuild){
  birdCountSubset <- birdCounts[birdCounts$foraging == foragingGuild,'count']
  return(sum(birdCountSubset))
}
```

We can then calculate the sum of bird counts for any of the guilds with a parsimonious line of code:

```{r, eval=FALSE}
  foragingSumFun('aerial')
  foragingSumFun('foliage')
  foragingSumFun('bark')
  foragingSumFun('ground')
```

We can also embed functions within functions. For example, perhaps we want to know the proportion of observed individuals in each foraging guild. We could use our foragingSum function to do so:

```{r, eval=FALSE}
foragingPropFun <- function(foragingGuild){
  foragingSumFun(foragingGuild)/sum(birdCounts$count)
}
  
foragingPropFun('ground')
```

Let's make our function even more flexible. Perhaps we are interested the proportional abundance of guilds for both dietary and foraging life history traits. We can write a function that would extract that information:

```{r, eval=FALSE}
traitGuildPropFun <- function(trait, guild){
  birdCountSubset <- birdCounts[birdCounts[,trait] == guild,'count']
  birdCountSum <- sum(birdCountSubset)
  return(birdCountSum/sum(birdCounts$count))
}

traitGuildPropFun('foraging', 'ground')

traitGuildPropFun('diet','insectivore')
```
----

> **Exercise Two:**
>
> 1. The mathematical formula for standard error is provided below. Convert this to an R function:
> $$StdErr (x) = \frac{StDev(x)}{\sqrt{n}}$$
>
>2. Create an function that calculates the mean proportion OF SPECIES (i.e., not counts) representing a selected diet guild across sites.
3. Create an function that calculates the mean proportion OF SPECIES (i.e., not counts) representing any selected trait and guild across sites.



### **If** I could, **else** I would

The "if" statement (and its friend "else") is fundamental to writing flexible functions. The basic format is:

```{r, eval=FALSE}
if(this conditional statement = TRUE){
  Do this} else {Do that
    } 
```

To explore the if statement, let's start by making a vector of numbers from 1 through 20:

```{r, eval=FALSE}
v1to20 <- 1:20
```


Let's write an if statement that replaces the value of v1to20 with a  "1" if the value within the vector is greater than the mean and "0" if it is less than the mean:


```{r, eval=FALSE}
if(v1to20 < mean(v1to20)){
  v1to20<-0
} else {v1to20 <- 1
} 
```